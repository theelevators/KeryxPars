@using KeryxPars.MessageViewer.Core.Models
@using KeryxPars.HL7.Contracts
@using KeryxPars.MessageViewer.Client.Services
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components.Rendering
@inject IJSRuntime JS
@implements IAsyncDisposable




<div class="raw-view">
    @if (Result?.Message != null && !string.IsNullOrEmpty(RawMessage))
    {
        <div class="raw-controls">
            <button class="btn-raw-control" @onclick="CopyToClipboard">
                <span class="bi bi-clipboard"></span>
                Copy
            </button>
            <button class="btn-raw-control" @onclick="ToggleLineNumbers">
                <span class="bi bi-list-ol"></span>
                @(showLineNumbers ? "Hide" : "Show") Line Numbers
            </button>
            <button class="btn-raw-control" @onclick="ToggleMetadata">
                <span class="bi bi-info-circle"></span>
                @(showMetadata ? "Hide" : "Show") Tooltips
            </button>
        </div>

        <div class="raw-container @(showLineNumbers ? "with-line-numbers" : "")">
            @{
                var lines = RawMessage.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
                for (int lineNum = 0; lineNum < lines.Length; lineNum++)
                {
                    var line = lines[lineNum];
                    if (string.IsNullOrWhiteSpace(line)) continue;

                    <div class="raw-line" @key="lineNum">
                        @if (showLineNumbers)
                        {
                            <span class="line-number">@(lineNum + 1)</span>
                        }
                        <span class="line-content">
                            @RenderLine(line, lineNum)
                        </span>
                    </div>
                }
            }
        </div>

        @if (hoveredField != null && showMetadata)
        {
            <div class="metadata-tooltip" style="@GetTooltipStyle()">
                <div class="tooltip-header">
                    <span class="tooltip-icon">
                        @if (hoveredField.IsComponent)
                        {
                            <span class="bi bi-dot"></span>
                        }
                        else
                        {
                            <span class="bi bi-hash"></span>
                        }
                    </span>
                    <strong>@hoveredField.Label</strong>
                </div>
                <div class="tooltip-body">
                    <div class="tooltip-section">
                        <div class="tooltip-field">
                            <span class="tooltip-label">Value:</span>
                            <span class="tooltip-value">@hoveredField.Value</span>
                        </div>
                        @if (!string.IsNullOrEmpty(hoveredField.Description))
                        {
                            <div class="tooltip-field description">
                                <span class="tooltip-label">
                                    <span class="bi bi-info-circle-fill"></span>
                                    Info:
                                </span>
                                <span class="tooltip-value">@hoveredField.Description</span>
                            </div>
                        }
                        <div class="tooltip-field meta">
                            <span class="tooltip-label">
                                <span class="bi bi-geo-alt-fill"></span>
                                Position:
                            </span>
                            <span class="tooltip-value">Line @hoveredField.LineNumber, Field @hoveredField.FieldIndex</span>
                        </div>
                        @if (hoveredField.IsComponent)
                        {
                            <div class="tooltip-field meta">
                                <span class="tooltip-label">
                                    <span class="bi bi-diagram-3"></span>
                                    Type:
                                </span>
                                <span class="tooltip-value">Component @hoveredField.ComponentIndex</span>
                            </div>
                        }
                    </div>
                </div>
            </div>
        }
    }
</div>

@code {
[Parameter]
public ParsedMessageResult? Result { get; set; }

[Parameter]
public string? RawMessage { get; set; }

private bool showLineNumbers = true;
private bool showMetadata = true;
private FieldMetadata? hoveredField;
private int mouseX;
private int mouseY;
private int viewportWidth = 1920;
private int viewportHeight = 1080;
private IJSObjectReference? viewportModule;

protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        try
        {
            viewportModule = await JS.InvokeAsync<IJSObjectReference>("import", "./js/viewport.js");
            await UpdateViewportSize();
        }
        catch
        {
            // Fallback to default values if JS interop fails
        }
    }
}

private async Task UpdateViewportSize()
{
    if (viewportModule != null)
    {
        try
        {
            var viewport = await viewportModule.InvokeAsync<ViewportSize>("getViewportSize");
            viewportWidth = viewport.Width;
            viewportHeight = viewport.Height;
        }
        catch
        {
            // Keep default values
        }
    }
}

private class ViewportSize
{
    public int Width { get; set; }
    public int Height { get; set; }
}

    private class FieldMetadata
    {
        public string Label { get; set; } = "";
        public string Value { get; set; } = "";
        public string? Description { get; set; }
        public int LineNumber { get; set; }
        public int FieldIndex { get; set; }
        public bool IsComponent { get; set; }
        public int ComponentIndex { get; set; }
    }

    private RenderFragment RenderLine(string line, int lineNum)
    {
        return builder =>
        {
            if (line.Length < 3) return;

            var segmentId = line.Substring(0, Math.Min(3, line.Length));
            var fields = line.Split('|');

            // Segment ID with color coding based on segment type
            builder.OpenElement(0, "span");
            builder.AddAttribute(1, "class", $"hl-segment hl-segment-{GetSegmentCategory(segmentId)}");
            if (showMetadata)
            {
                builder.AddAttribute(2, "onmouseenter", EventCallback.Factory.Create<MouseEventArgs>(this,
                    e => OnSegmentHover(segmentId, lineNum + 1, (int)e.ClientX, (int)e.ClientY)));
                builder.AddAttribute(3, "onmouseleave", EventCallback.Factory.Create(this, () => hoveredField = null));
            }
            builder.AddContent(4, segmentId);
            builder.CloseElement();

            // Field separator
            if (fields.Length > 1)
            {
                builder.OpenElement(5, "span");
                builder.AddAttribute(6, "class", "hl-separator hl-separator-field");
                builder.AddContent(7, "|");
                builder.CloseElement();
            }

            // Fields
            for (int i = 1; i < fields.Length; i++)
            {
                // Capture loop variables to avoid closure issues
                var field = fields[i];
                var fieldIndex = i;

                builder.OpenElement(8 + i * 20, "span");
                builder.AddAttribute(9 + i * 20, "class", "hl-field");
                
                if (showMetadata)
                {
                    builder.AddAttribute(10 + i * 20, "onmouseenter", EventCallback.Factory.Create<MouseEventArgs>(this, 
                        e => OnFieldHover(segmentId, fieldIndex, field, lineNum + 1, (int)e.ClientX, (int)e.ClientY)));
                    builder.AddAttribute(11 + i * 20, "onmouseleave", EventCallback.Factory.Create(this, () => hoveredField = null));
                }

                // Check for various delimiters
                RenderFieldContent(builder, field, segmentId, fieldIndex, lineNum, i);

                builder.CloseElement();

                // Field separator
                if (i < fields.Length - 1)
                {
                    builder.OpenElement(21 + i * 20, "span");
                    builder.AddAttribute(22 + i * 20, "class", "hl-separator hl-separator-field");
                    builder.AddContent(23 + i * 20, "|");
                    builder.CloseElement();
                }
            }

        };
    }

    private void RenderFieldContent(RenderTreeBuilder builder, string field, string segmentId, int fieldIndex, int lineNum, int i)
    {
        // Handle repetitions (~)
        if (field.Contains('~'))
        {
            var repetitions = field.Split('~');
            for (int r = 0; r < repetitions.Length; r++)
            {
                RenderComponentOrValue(builder, repetitions[r], segmentId, fieldIndex, lineNum, i * 100 + r * 10);
                
                if (r < repetitions.Length - 1)
                {
                    builder.OpenElement(i * 100 + r * 10 + 5, "span");
                    builder.AddAttribute(i * 100 + r * 10 + 6, "class", "hl-separator hl-separator-repetition");
                    builder.AddContent(i * 100 + r * 10 + 7, "~");
                    builder.CloseElement();
                }
            }
        }
        else
        {
            RenderComponentOrValue(builder, field, segmentId, fieldIndex, lineNum, i * 100);
        }
    }

    private void RenderComponentOrValue(RenderTreeBuilder builder, string value, string segmentId, int fieldIndex, int lineNum, int baseIndex)
    {
        // Check for components (^)
        if (value.Contains('^'))
        {
            var components = value.Split('^');
            for (int c = 0; c < components.Length; c++)
            {
                // Check for subcomponents (&)
                if (components[c].Contains('&'))
                {
                    var subcomponents = components[c].Split('&');
                    for (int s = 0; s < subcomponents.Length; s++)
                    {
                        RenderValue(builder, subcomponents[s], segmentId, fieldIndex, c + 1, lineNum, baseIndex + c * 5 + s);
                        
                        if (s < subcomponents.Length - 1)
                        {
                            builder.OpenElement(baseIndex + c * 5 + s + 1, "span");
                            builder.AddAttribute(baseIndex + c * 5 + s + 2, "class", "hl-separator hl-separator-subcomponent");
                            builder.AddContent(baseIndex + c * 5 + s + 3, "&");
                            builder.CloseElement();
                        }
                    }
                }
                else
                {
                    RenderValue(builder, components[c], segmentId, fieldIndex, c + 1, lineNum, baseIndex + c * 5);
                }
                
                if (c < components.Length - 1)
                {
                    builder.OpenElement(baseIndex + c * 5 + 4, "span");
                    builder.AddAttribute(baseIndex + c * 5 + 5, "class", "hl-separator hl-separator-component");
                    builder.AddContent(baseIndex + c * 5 + 6, "^");
                    builder.CloseElement();
                }
            }
        }
        else
        {
            RenderValue(builder, value, segmentId, fieldIndex, 0, lineNum, baseIndex);
        }
    }

    private void RenderValue(RenderTreeBuilder builder, string value, string segmentId, int fieldIndex, int componentIndex, int lineNum, int baseIndex)
    {
        if (string.IsNullOrEmpty(value))
        {
            // Just render empty space, don't show "(empty)"
            return;
        }

        // Check for escape sequences
        if (value.Contains('\\'))
        {
            var parts = value.Split('\\');
            for (int p = 0; p < parts.Length; p++)
            {
                if (p > 0)
                {
                    builder.OpenElement(baseIndex + p * 3, "span");
                    builder.AddAttribute(baseIndex + p * 3 + 1, "class", "hl-escape");
                    builder.AddContent(baseIndex + p * 3 + 2, "\\");
                    builder.CloseElement();
                }
                
                if (!string.IsNullOrEmpty(parts[p]))
                {
                    builder.OpenElement(baseIndex + p * 3 + 3, "span");
                    builder.AddAttribute(baseIndex + p * 3 + 4, "class", GetValueClass(value, segmentId, fieldIndex));
                    
                    if (showMetadata && componentIndex > 0)
                    {
                        builder.AddAttribute(baseIndex + p * 3 + 5, "onmouseenter", EventCallback.Factory.Create<MouseEventArgs>(this,
                            e => OnComponentHover(segmentId, fieldIndex, componentIndex, value, lineNum, (int)e.ClientX, (int)e.ClientY)));
                        builder.AddAttribute(baseIndex + p * 3 + 6, "onmouseleave", EventCallback.Factory.Create(this, () => hoveredField = null));
                    }
                    
                    builder.AddContent(baseIndex + p * 3 + 7, parts[p]);
                    builder.CloseElement();
                }
            }
        }
        else
        {
            builder.OpenElement(baseIndex, "span");
            builder.AddAttribute(baseIndex + 1, "class", GetValueClass(value, segmentId, fieldIndex));
            
            if (showMetadata && componentIndex > 0)
            {
                builder.AddAttribute(baseIndex + 2, "onmouseenter", EventCallback.Factory.Create<MouseEventArgs>(this,
                    e => OnComponentHover(segmentId, fieldIndex, componentIndex, value, lineNum, (int)e.ClientX, (int)e.ClientY)));
                builder.AddAttribute(baseIndex + 3, "onmouseleave", EventCallback.Factory.Create(this, () => hoveredField = null));
            }
            
            builder.AddContent(baseIndex + 4, value);
            builder.CloseElement();
        }
    }


    private string GetValueClass(string value, string segmentId, int fieldIndex)
    {
        // Detect different value types for syntax highlighting
        
        // Date/Time patterns (YYYYMMDD or YYYYMMDDHHMMSS)
        if (value.Length >= 8 && value.Length <= 14 && value.All(char.IsDigit))
            return "hl-value hl-value-datetime";
        
        // Numeric values
        if (decimal.TryParse(value, out _))
            return "hl-value hl-value-number";
        
        // IDs (contains numbers and uppercase)
        if (value.Length > 0 && value.Any(char.IsDigit) && value.Any(char.IsUpper))
            return "hl-value hl-value-id";
        
        // Codes (all uppercase, 1-5 chars)
        if (value.Length > 0 && value.Length <= 5 && value.All(c => char.IsUpper(c) || char.IsDigit(c)))
            return "hl-value hl-value-code";
        
        // Default text
        return "hl-value hl-value-text";
    }

    private string GetSegmentCategory(string segmentId)
    {
        return segmentId switch
        {
            "MSH" => "header",
            "EVN" => "event",
            "PID" or "PD1" => "patient",
            "PV1" or "PV2" => "visit",
            "ORC" or "OBR" or "OBX" => "order",
            "RXE" or "RXO" or "RXA" or "RXD" or "RXR" or "RXC" or "RXG" => "pharmacy",
            "AL1" => "allergy",
            "DG1" => "diagnosis",
            "IN1" or "IN2" => "insurance",
            "NK1" => "contact",
            "NTE" => "note",
            _ => "other"
        };
    }


    private void OnSegmentHover(string segmentId, int lineNumber, int x, int y)
    {
        mouseX = x;
        mouseY = y;
        hoveredField = new FieldMetadata
        {
            Label = segmentId,
            Value = segmentId,
            Description = HL7MetadataService.GetSegmentDescription(segmentId),
            LineNumber = lineNumber,
            FieldIndex = 0,
            IsComponent = false
        };
    }

    private void OnFieldHover(string segmentId, int fieldIndex, string value, int lineNumber, int x, int y)
    {
        mouseX = x;
        mouseY = y;
        hoveredField = new FieldMetadata
        {
            Label = $"{segmentId}.{fieldIndex}",
            Value = value,
            Description = HL7MetadataService.GetFieldDescription(segmentId, fieldIndex),
            LineNumber = lineNumber,
            FieldIndex = fieldIndex,
            IsComponent = false
        };
    }

    private void OnComponentHover(string segmentId, int fieldIndex, int componentIndex, string value, int lineNumber, int x, int y)
    {
        mouseX = x;
        mouseY = y;
        hoveredField = new FieldMetadata
        {
            Label = $"{segmentId}.{fieldIndex}.{componentIndex}",
            Value = value,
            Description = HL7MetadataService.GetComponentDescription(segmentId, fieldIndex, componentIndex),
            LineNumber = lineNumber,
            FieldIndex = fieldIndex,
            IsComponent = true,
            ComponentIndex = componentIndex
        };
    }

    private string GetTooltipStyle()
    {
        // Tooltip dimensions (approximate)
        const int tooltipWidth = 500;
        const int tooltipHeight = 200;
        const int offset = 10;
        const int edgeMargin = 20;
        
        // Calculate initial position (bottom-right of cursor)
        int left = mouseX + offset;
        int top = mouseY + offset;
        
        // Check if tooltip would go off the right edge
        if (left + tooltipWidth > viewportWidth - edgeMargin)
        {
            // Flip to left of cursor
            left = mouseX - tooltipWidth - offset;
            
            // If still offscreen, clamp to viewport
            if (left < edgeMargin)
            {
                left = Math.Max(edgeMargin, viewportWidth - tooltipWidth - edgeMargin);
            }
        }
        
        // Check if tooltip would go off the bottom edge
        if (top + tooltipHeight > viewportHeight - edgeMargin)
        {
            // Flip to above cursor
            top = mouseY - tooltipHeight - offset;
            
            // If still offscreen, clamp to viewport
            if (top < edgeMargin)
            {
                top = edgeMargin;
            }
        }
        
        // Ensure minimum distance from edges
        left = Math.Max(edgeMargin, Math.Min(left, viewportWidth - tooltipWidth - edgeMargin));
        top = Math.Max(edgeMargin, Math.Min(top, viewportHeight - tooltipHeight - edgeMargin));
        
        return $"left: {left}px; top: {top}px;";
    }

    public async ValueTask DisposeAsync()
    {
        if (viewportModule != null)
        {
            try
            {
                await viewportModule.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }



    private void ToggleLineNumbers()
    {
        showLineNumbers = !showLineNumbers;
    }

    private void ToggleMetadata()
    {
        showMetadata = !showMetadata;
    }

    private async Task CopyToClipboard()
    {
        // Note: Clipboard API would need JS interop
        // This is a placeholder
    }
}

